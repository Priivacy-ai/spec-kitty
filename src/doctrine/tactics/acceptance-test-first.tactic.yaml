schema_version: "1.0"
id: acceptance-test-first
name: Acceptance Test Driven Development (ATDD)
purpose: Anchor implementation work in externally observable behavior before internal coding begins.
steps:
  - title: Define acceptance behavior first
    description: Capture the intended user-visible outcome as an executable acceptance test before implementation starts.
    examples:
      - "Add a CLI integration test that describes expected command output before editing command handlers."
  - title: Attach traceability metadata
    description: Link each acceptance scenario to the governing task, ticket, or requirement identifier.
    examples:
      - "Include the work package ID in the test name or fixture metadata."
  - title: Keep acceptance checks black-box
    description: Exercise real workflows through public interfaces instead of internal seams.
    examples:
      - "Validate HTTP behavior via endpoint calls rather than internal service mocks."
  - title: Balance acceptance coverage
    description: Keep acceptance tests few but meaningful, then push detail into lower test layers.
    examples:
      - "One end-to-end scenario per capability plus focused unit tests for decision logic."
  - title: Handoff to code-level TDD
    description: After acceptance tests fail for the right reason, continue with Red-Green-Refactor cycles for implementation detail.
    examples:
      - "Use failing acceptance test as the outer guard while adding unit-level TDD increments."
  - title: Document manual fallbacks
    description: When automation is not feasible, record the fallback procedure and rationale for review.
    examples:
      - "Capture hardware-vendor limitation and manual verification checklist in the task log."
