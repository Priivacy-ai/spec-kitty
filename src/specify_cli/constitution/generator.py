"""Deterministic constitution markdown generator."""

from __future__ import annotations

from dataclasses import dataclass
from pathlib import Path

from specify_cli.constitution.catalog import DoctrineCatalog, load_doctrine_catalog
from specify_cli.constitution.resolver import DEFAULT_TOOL_REGISTRY


@dataclass(frozen=True)
class ConstitutionDraft:
    """Draft constitution with deterministic doctrine selections."""

    mission: str
    template_set: str
    selected_paradigms: list[str]
    selected_directives: list[str]
    available_tools: list[str]
    markdown: str


def build_constitution_draft(
    *,
    mission: str,
    template_set: str | None = None,
    doctrine_catalog: DoctrineCatalog | None = None,
) -> ConstitutionDraft:
    """Build deterministic constitution markdown for a mission."""
    catalog = doctrine_catalog or load_doctrine_catalog()
    selected_paradigms = sorted(catalog.paradigms)
    selected_directives = sorted(catalog.directives)
    available_tools = sorted(DEFAULT_TOOL_REGISTRY)

    resolved_template_set = _resolve_template_set(
        mission=mission,
        requested_template_set=template_set,
        catalog=catalog,
    )
    markdown = _render_markdown(
        mission=mission,
        template_set=resolved_template_set,
        selected_paradigms=selected_paradigms,
        selected_directives=selected_directives,
        available_tools=available_tools,
        catalog=catalog,
    )

    return ConstitutionDraft(
        mission=mission,
        template_set=resolved_template_set,
        selected_paradigms=selected_paradigms,
        selected_directives=selected_directives,
        available_tools=available_tools,
        markdown=markdown,
    )


def _resolve_template_set(
    *,
    mission: str,
    requested_template_set: str | None,
    catalog: DoctrineCatalog,
) -> str:
    if requested_template_set:
        if catalog.template_sets and requested_template_set not in catalog.template_sets:
            options = ", ".join(sorted(catalog.template_sets))
            raise ValueError(
                f"Unknown template set '{requested_template_set}'. Available template sets: {options}"
            )
        return requested_template_set

    mission_default = f"{mission}-default"
    if mission_default in catalog.template_sets:
        return mission_default

    if catalog.template_sets:
        return sorted(catalog.template_sets)[0]

    return mission_default


def write_constitution(path: Path, markdown: str, *, force: bool = False) -> None:
    """Write constitution markdown to disk."""
    if path.exists() and not force:
        raise FileExistsError(f"Constitution already exists at {path}. Use --force to overwrite.")
    path.parent.mkdir(parents=True, exist_ok=True)
    path.write_text(markdown, encoding="utf-8")


def _yaml_list(values: list[str]) -> str:
    if not values:
        return "[]"
    return "[" + ", ".join(values) + "]"


def _render_markdown(
    *,
    mission: str,
    template_set: str,
    selected_paradigms: list[str],
    selected_directives: list[str],
    available_tools: list[str],
    catalog: DoctrineCatalog,
) -> str:
    directive_rules = _render_directive_rules(selected_directives)
    paradigms_catalog = ", ".join(sorted(catalog.paradigms)) or "(none packaged)"
    directives_catalog = ", ".join(sorted(catalog.directives)) or "(none packaged)"
    template_sets_catalog = ", ".join(sorted(catalog.template_sets)) or "(none packaged)"
    tools_catalog = ", ".join(available_tools)

    return (
        "# Project Constitution\n\n"
        "<!-- Generated by `spec-kitty constitution generate` -->\n\n"
        "## Testing Standards\n\n"
        "- Minimum coverage: 80%\n"
        "- TDD requirement: required\n"
        "- Test framework: pytest\n"
        "- Type checking: mypy --strict\n\n"
        "## Quality Gates\n\n"
        "- Linting: ruff\n"
        "- PR approvals: 1\n"
        "- Pre-commit checks: enabled\n\n"
        "## Governance Activation\n\n"
        "```yaml\n"
        f"mission: {mission}\n"
        f"selected_paradigms: {_yaml_list(selected_paradigms)}\n"
        f"selected_directives: {_yaml_list(selected_directives)}\n"
        f"available_tools: {_yaml_list(available_tools)}\n"
        f"template_set: {template_set}\n"
        "```\n\n"
        "## Project Directives\n\n"
        f"{directive_rules}\n\n"
        "## Doctrine Catalog Snapshot\n\n"
        f"- Paradigms: {paradigms_catalog}\n"
        f"- Directives: {directives_catalog}\n"
        f"- Template Sets: {template_sets_catalog}\n"
        f"- Tools: {tools_catalog}\n"
    )


def _render_directive_rules(directive_ids: list[str]) -> str:
    if not directive_ids:
        return "1. Keep specification, plan, tasks, and implementation artifacts in sync."
    return "\n".join(
        f"{idx}. Apply doctrine directive `{directive_id}` consistently across all workflow phases."
        for idx, directive_id in enumerate(directive_ids, start=1)
    )
